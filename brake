#!/usr/bin/env ruby

require 'rake'
require 'yaml'
require 'singleton'

ON_WINDOWS = RUBY_PLATFORM =~ /(:?mswin|mingw32)/

$LOAD_PATH.unshift(File.expand_path(File.dirname(__FILE__)))

module Brake
  module Logging
    # Log line
    def log(s, level = :normal)
       logn(s)
       print "\n"
    end

    # Log, but stay on the same line 
    def logn(s, level = :normal)
      print "-- " + s
    end
    
    # Continue log line
    def logc(s)
      print s, "\n"
    end
  end

  class << self
    # Current Brake Application
    def application
      unless @application
        # Tie rake stuff to our application object
        Rake.application = @application = Brake::Application.new
      end

      @application
    end

    def cache
      @cache ||= Brake::Cache.new
    end
  end

  class Cache
    def initialize
      load

      @cache ||= {}
      @cache[:compilers] ||= {}
    end

    def [](key)
      @cache[key]
    end

    def []=(key, val)
      @cache[key] = val
    end

    def load
      @cache_file_name ||= File.join(Brake.application.original_dir, ".cache.yaml")
      @cache = YAML.load(File.open(@cache_file_name)) rescue {}
    end

    def save
      File.open(@cache_file_name, "w") do |f|
        YAML.dump(@cache, f)
      end
    end
  end

  module Checks
    include Brake::Logging

    def find_program(program_name, paths = [])
      test_block = 
        if ON_WINDOWS then 
          proc do |f| File.exists?(f) end
        else
          proc do |f| File.executable?(f) end
        end

      logn("Checking for program #{program_name}...")

      (paths + ENV['PATH'].split(':')).each do |path|
        fname = File.join(path, program_name)
        fname += ".exe" if ON_WINDOWS
    
        if test_block.call(fname)
          fname = File.expand_path(fname)

          logc(" found at #{fname}")

          return fname
        end
      end
    
      logc(" not found")
      nil
    end
  end

  module Compilers
    class Compiler
      include Brake::Logging

      def initialize(name, options)
        @name = name
        @options = options
      end

      def probed?
        Brake.cache[:compilers][@name][:probed] rescue false
      end

      def probe
        unless probed?
          @conf = {}

          if detect
            Brake.cache[:compilers][@name] = @conf.merge({:probed => true})
            Brake.cache.save
          end
        end
      end
    end

    class << self
      def register(type, klass)
        @classes ||= Hash.new
        @classes[type] ||= klass
      end

      def [](type)
        @classes[type]
      end
    end
  end

  class Application < Rake::Application
    DEFAULT_BRAKEFILES = ['brakefile', 'Brakefile', 'brakefile.rb', 'Brakefile.rb'].freeze

    attr_reader :original_dir

    def initialize
      super
      @rakefiles = DEFAULT_BRAKEFILES.dup
      @compilers = {}
    end
    
    def run
      standard_exception_handling do
        init('brake')
        load_rakefile
        top_level
      end
    end

    def add_compiler(name, klass, options)
      @compilers[name] ||= klass.new(name, options)

      @compilers[name].probe
    end
  end
end

def compiler(type, options = {})
  require "compilers/#{type}"

  Brake.application.add_compiler(options[:name] || type, Brake::Compilers[type], options)
end

Brake.application.run
